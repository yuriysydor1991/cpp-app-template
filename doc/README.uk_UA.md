**Твій шаблон для С++ програми**

# Ціль проекту-шаблону

Проект-шаблон призначений для пришвидшення процесу побудови програми на стадії започаткування проекту за допомогою готової початкової структури програми. Отож розробник може одразу перейти до реалізації конкретної програми з мінімальними затратами на базову структуру.

**Створи форк і одразу реалізуй свою програму!**

Переглянь доступні гілки у репозиторії проекту-шаблону і використай найбільш підходящий варіант (**на даний момент існує тільки одна гілка**).

Редагуй поточний README.md щоб документація відповідала впровадженому коду.

Більше за посиланням [kytok.org.ua](http://www.kytok.org.ua/)

# Клонування С++ проекту-шаблону

Щоб негайно розпочати реалізування нової програми склонуй поточний проекту у свою локальну директорію, виконавши наступну команду в терміналі (для GNU/Linux):

```
git clone https://github.com/yuriysydor1991/cpp-app-template.git
```

Після успішного виконання даної команди у поточній відкритій директорї повинна з'явитись нова під директорія `cpp-app-template`. Отож відкрий її за допомогою команди `cd cpp-app-template`.

# Створення форку і заміна оригінального репозиторію

Для того щоб увесь вміст проекту-шаблону скопіювати у свій чистий новостворений `git`-репозиторій (**без жодних файлів** на подобі `README.md`, `.gitignore`, `LICENCE` або будь-яких інших), склонуй поточний проект-шаблон `cpp-app-template` у свою локальну директорію і виконай заміну посилання оригінального рипозиторію на власний всередині директорії проекту-шаблону:

```
# Заміни наступний URL на власний з нового репозиторію

git remote set-url origin https://github.com/yuriysydor1991/cpp-app-template.git
```

Заміни оригінальне посилання проекту-шаблону `https://github.com/yuriysydor1991/cpp-app-template.git` на власний від свого новоствореного `git`-репозиторію.

Для того щоб перевірити чи замінився URL для проекту-шаблону (куди будуть надсилатись усі зміни) необхідно виконати наступну команду:

```
git remote -v
```

Після виконання якої у терміналі повинно висвітлитись нове посилання на новий проект.

Тепер можна скопіювати усі зміни до нового розміщення, виконуючи наступну команду:

```
git push
```

Створення форку може бути виконаним через Web-панель інтерфейсу git.

# Вимоги

Дана секція містить список усіх вимог до пакунків, програм чи інструментів які повинні бути встановленими у системі для того щоб побудувати проект-шаблон чи виконати інші функції.

## Обов'язкові інструменти для ОС на базі GNU/Лінукс

Для того щоб виконати побудову проекту-шаблону необхідно встановити компілятор GCC C++ разом з системою побудови проекту CMake і системою версіювання Git:

```
sudo apt install -y git g++ cmake
```

## Необов'язкові пакети для тестів

Якщо необхідно побудувати і виконати доступні тести необхідно встановити GTest або забезпечити доступ до мережі Інтернет у випадку самостійного встановлення скриптами системи збірки CMake проекту-шаблону. Для встановлення необхідно виконати команду:

```
sudo apt install -y googletest
```

Більш детально у секції [тести проекту](#тести-проекту).

## Необов'язкові пакети для створення документації

Якщо необхідно генерувати документацію за допомогою інструменту Doxygen з коментарів файлів вихідного джерельного коду необхідно виконати команду:

```
sudo apt install -y doxygen graphviz
```

Переглянь секцію [Побудова документації](#побудова-документації) як увімкнути підтримку побудови/встановлення документації.

## Необов'язкові пакети для форматування коду

Для підтримки автоматичного форматування коду за допомогою наявної CMake-цілі `clang-format` відповідний інструмент `clang-format` повинен бути встановленим наступною командою (для GNU/Linux систем):

```
sudo apt install -y clang-format
```

Переглянь деталі конфігурації у секції [Вмикання і виконання цілі форматування коду](#вмикання-і-виконання-цілі-форматування-коду)

## Необов'язкові пакети для статичного аналізатора коду cppcheck

Для того щоб виконувати статичний аналіз коду за допомогою команди `cppcheck` встановіть її наступною командою:

```
sudo apt install -y cppcheck
```

Більш детальніше у секції [Вмикання цілі статичного аназу коду з cppcheck](#вмикання-цілі-статичного-аназу-коду-з-cppcheck).

## Необов'язкові пакет для перевірки використання пам'яті за допомогю Valgrind

Для того щоб виконувати перевірку динамічного використання пам'яті за допомогою команди `valgrind` необхідно встановити її за допомогою наступної команди:

```
sudo apt install -y valgrind
```

Біль детально у секції [Вмикання цілі динамічної перевірки пам'яті з valgrind](#вмикання-цілі-динамічної-перевірки-пам'яті-з-valgrind).

# Структура проекту

## Реалізуй код одразу!

Щоб одразу приступити до реалізації конкретної програми необхідно перейти до файлу `Application.cpp` відповідного класу, який призначений для утримання початкового коду реалізації програми. Більш точно новий код повинен бути розміщений у методі `int Application::run(std::shared_ptr<ApplicationContext> ctx)`.

**Але пам'ятаємо про принципи хорошого коду SOLID і його декомпозицію!**

Рекомендується створити нові окремі директоріх у проекті котрі будуть розміщувати додаткові реалізовані компоненти програми і включити їх до реалізації класу `Application`. На противагу розміщення усього коду тільки всередині класу `Application` (для тривіального проекту це може бути оправданим).

## Зміна назви проекту і головного виконуваного файлу

Після клонування і копіювання проекту-шаблону необхідно замінити назву проекту і його основного бінарного виконуваного файлу у корінному файлі `CMakeLists.txt`, запроваджуючи нове значення для CMake-змінних `PROJECT_NAME` і/або  `PROJECT_BINARY_NAME`. Рекомендується виконувати заміну назв для того щоб нова програма предаставляла новий конкретний проект замість назви за замовчуванням - `CppAppTemplate` і запобіганню конфліктів під час встановлення виконуваного файлу у цільову систему.

## Впровадження нових параметрів командного рядка

Для того щоб впровадити нові параметри командного рядка для головного виконуваного файлу проекту-шаблона необхідно редагувати реалізацію класу `CommandLineParser`. Котрий у свою чергу містить методи розпізнавання параметрів командного рядка котрі передаються об'єктом класу `ApplicationFactory` після виклику головної функції `main` операційною системою.

Необхідно впровадити додаткові члени класу `ApplicationContext` щоб передавати додаткову інформацію з параметрів командного рядка до нащадків абстрактного класу `IApplication` (і відповідно впливати на їхню поведінку у відповідності до вводу користувача) що буде створений за допомогою обє'кта класу `ApplicationFactory` під час виконання розбору параметрів командного рядка.

## Реалізація власних нащадків IApplication

Звісно що можна реалізувати окремий новий потомок абстракного класу `IApplication` щоб реалізувати високорівненву варіативність поведінки виконуваного файлу без засмічування незв'язаними `if`-виразами і іншим кодом оригінального класу `Application` (у якому буде міститись реалізація за умовчанням) (пам'ятаймо про принцип Єдиної відповідальності від SOLID).

Створення потомка абстрактного класу `IApplication` може бути виконаним за допомогою прямого безпосереднього створення нового потомка-класу або перевизначенням наявних класів-потомків `IApplication` на подобі `Application`, `ApplicationHelpPrinter` або `ApplicationVersionPrinter`.

Зареєструй новостворений клас-потомок абстрактного класу `IApplication` у методі `create_application` від `ApplicationFactory`, який відповідальний за створення необхідної релазації програми у відповідності до вводу користувача у вигляді параметрів командного рядка.

Це може бути виконаним реалізацією нового потомка класу `ApplicationFactory` і віртальним перевизначенням його створюючих методів на подобі `create_application` і/або інших (потрібно також викликати відповідний статичний метод у головній функції виконуваного бінарного файлу `main` що розміщена у файлі `main.cpp`).

## Версіювання і інші параметри проекту

Під час конфігурації файлів побудови проекту файли побудови `CMakeLists.txt` системи CMake відслідковують поточний хеш коміту проекту, ім'я проекту, дату конфігурації і версію проекту. Дані параметри проекту передаються у файл кодової конфігурації проекту що знаходиться за шляхом `src/app/project-global-decls.h.in`. Файл `src/app/project-global-decls.h.in` буде скомпільовано системою CMake під час конфігурації проекту у кореневу директорію побудови проекту у якості `project-global-decls.h`. Клас `ApplicationVersionPrinter` включає даний файл кодової конфігурації проекту і використовує надану з нього інформацію для відображення відповідного повідомлення версії програми у термінал. Зазвичай, даний код виконується під час виклику основного бінарного виконуваного файлу проекту з прапорцями командного рядка на подобі `-v` або `--version`. Після друку версії і іншої допоміжної інформації у відкритий термінал, реалізація за замовчуванням класу `ApplicationVersionPrinter` повертає нульовий стан виконання програми (індикатор успішного безпомилкового виконання) і після чого виконуваний бінарний файл завершує свою роботу.

## Тести проекту

Проект-шаблон вже "з коробки" містить деякі прості примірники тестів. Спираючись на них, можна реалізовувати повноцінні тести нововпровадженого коду.

Більш детально у секції [Побудова проекту](#побудова-проекту) про те як увімкнути підтримку побудови тестів за допомогою CMake.

### Фреймворк тестів Google Test

На даний момент приклади тестів опираються на фреймворк GTest. Фреймворк GTest стає доступним у проекті за допомогою команд CMake на подобі `FetchContent_Declare`/`FetchContent_MakeAvailable` (за допомогою доступу до мережі Інтернет) у випадку, якщо система не предоставляє фреймворк тестування.

Звісно, скрипти `CMakeLists.txt` визначають чи у ОС побудови проекту присутній фреймворк тестування GTest тільки якщо самі тести проекту-шаблону увімкнені прапорцем `ENABLE_UNIT_TESTS`. Використання фреймворку тестування GTest присутнього у системі можна вимкнути встановленням відповідного значення для CMake-змінної `GTEST_TRY_SYSTEM_PROBE`.

Детальніше у файлі відповідальному за встановлення джерела GTest за шляхом `cmake/template-project-make-GTest-available.cmake` де також можна змінити версію фреймворку тестування тощо.

## Розширення

Так як проект-шаблон ще розробляється то у майбутньому будуть впроваджені нові можливості.

# Побудова проекту

## Побудова за допомогою IDE

Звісно якщо використовуване інтегроване середовище розробки, себто IDE, підтримує інтеграцію з системою побудови CMake, тоді можна просто натиснути відповідні кнопки "Побудувати" і/або "Запустити" які розміщені десь у вікні середовища, і готово! Не потрібно виконувати команди конфігурації, побудови, пошуку виконуваного файлу і його виконання. Усе виконується автоматично самим середовищем автоматичної побудови.

## Побудова проекту-шаблону через командний рядок

Проект використовує систему побудови CMake - отож команди побудови мають бути знайомими більшосі C++ розробників на планеті!

Звісно, проект-шаблон спочатку потребує клонування за допомогою команди `git clone <URL>` і його коренева директорія повинна бути відкритою у використовуваному IDE. Після чого можна виконати команди:

```
# всередині кореневої директорії проекту-шаблону

mkdir -vp build && cd build && cmake ../ && cmake --build . --target all
```

Яка у свою чергу створить директорію `build` (директорія вже додана до файлу `.gitignore`), конфігурує проект використовуючи доступну у ОС версію системи побудови CMake (детальніше у секції [Вимоги](#вимоги) даного документу), і на кінець, будує усі цілі доступні у проекті-шаблоні.

## Вмикання тестів

### Вмикання юніт-тестів

Для того щоб зробити юніт тестування доступним (для побудови і запуску) необхідно перекорфігурувати проект-шаблон з увімкненою опцією `ENABLE_UNIT_TESTS` за допомогою команди (для GNU/Linux):

```
# у кореневій директорії проекту

mkdir -vp build && cd build && cmake ../ -DENABLE_UNIT_TESTS=ON && cmake --build . --target all
```

### Запобігання використання GTest з ОС

Для вимкнення використання ресурсів наявного фреймворку GTest необхідно встановити відповідне значення для CMake-змінної `GTEST_TRY_SYSTEM_PROBE` за допомогою команди конфігурування проекту (для GNU/Linux):

```
# з кореневої директорії проекту-шаблону

mkdir -vp build && cd build && cmake ../ -DENABLE_UNIT_TESTS=ON -DGTEST_TRY_SYSTEM_PROBE=OFF && cmake --build . --target all
```

Під час виконання команди система побудови проекту спробує встановити GTest тільки у межах поточного проекту через мережу Інтернет з версією вказаною у файлі `cmake/template-project-make-GTest-available.cmake`.

## Побудова документації

На даний момент доступна побудова документації за допомогою програми Doxygen з наявних коментарів вихідного джерельного коду проекту.

Для того щоб зробити доступною ціль для побудови документації за допомогою Doxygen під час його конфігурації необхідно встановити змінну `ENABLE_DOC_DOXYGEN` у значення `ON` (для ОС на базі GNU/Linux):

```
# з кореневої директорії проекту-шаблону

mkdir -vp build && cd build && cmake ../ -DENABLE_DOC_DOXYGEN=ON
```

Яка в свою чергу створить директорію з назвою `build` всередині кореневої директорію проекту-шаблону, відкриє її за допомогою команди `cd` і сконфігурує проект з увімкненою ціллю для побудови Doxygen документації.

На кінкець можна побудувати документацію виконуючи команду:

```
# всередині директорії побудови проекту

cmake --build . --target Doxygen-doc
```

Яка у свою чергу створює директорію `doc/CppAppTemplate-html` (вже додана до файлу `.gitignore`) що буде містити зібрану документацію у вигляді HTML-сторінок і ресурсів до них. Для того щоб відкрити і оглянути згенеровану документацію необхідно відкрити файл який лежить за шляхом `doc/CppAppTemplate-html/index.html` від кореня проекту. Директорія `CppAppTemplate-html` змінить назву у відповідності до зміни назви головного виконуваного файлу проекту-шаблону за допомогою встановлення нового значення для змінної `PROJECT_BINARY_NAME` у файлі `cmake/template-project-misc-variables-declare.cmake` або змінну `DOXYGEN_OUT_HTML_NAME` яка визначає ім'я для цілої цільової директорії для згенерованої HTML-документації.

Файл `doc/Doxyfile.in` від кореня проекту містить усі параметри конфігурації які можуть бути зміненими для зміни виводу документації.

## Вмикання підтримки встановлення документації

Наявна можливість підтримки встановлення документації за допомогою встановлення змінних `ENABLE_DOC_DOXYGEN` і `DOXYGEN_DO_INSTALL` у значення `ON` під час конфігурування прокету-шаблону за допомогою команди:

```
# inside the project build directory

cmake ../ -DENABLE_DOC_DOXYGEN=ON -DDOXYGEN_DO_INSTALL=ON
```

Змінна `DOXYGEN_OUT_HTML_NAME` сконфігурує назву для директорії HTML документації (передається до файлу `Doxyfile`).

## Вмикання підтримки форматування коду

Для того щоб зробити доступною ціль `clang-format` необхідно встановити змінну `ENABLE_CLANGFORMAT` у значення `ON` під час конфігурації проекту-шаблону (для GNU/Linux ОС):

```
# всередині кореня проекту-шаблону

mkdir -vp build && cd build && cmake ../ -DENABLE_CLANGFORMAT=ON
```

Для того щоб виконати форматування коду усього проекту-шаблону у відповідності до стандартів вказаних у файлі `misc/.clang-format` необхідно виконати наступну команду:

```
# всередині директорії побудови проекту-шаблона

cmake --build . --target clang-format
```

Деталі цілі `clang-format` можна перегляну у файлі `cmake/template-project-clang-format-target.cmake` субмодуля системи CMake.

## Вмикання підтримки цілі статичного аналізатора коду cppcheck

Для того щоб зробити доступною для виконання ціль статичного аналізу за допомогою `cppcheck` необхідно сконфігурувати проект з увімкненою опцією `ENABLE_CPPCHECK`:

```
# всередині кореневої директорії проекту-шаблону

mkdir -vp build && cd build && cmake ../ -DENABLE_CPPCHECK=ON
```

І для безпосереднього виконання статичного аналізу коду необхідно викликати ціль `cppcheck` для побудови:

```
# всередині директорії побудови проекту-шаблону

cmake --build . --target cppcheck
```

Деталі цілі `cppcheck` можна перегляну і/або змінити у файлі `cmake/template-project-cppcheck-target.cmake` системи збірки CMake.

## Вмикання цілі динамічної перевірки пам'яті Valgrind

Для того щоб увімкнути для побудови ціль `valgrind` необхідно сконфігурувати проект з увімкненою опцією `ENABLE_VALGRIND` на подобі наступної команди (для GNU/Linux ОС і подібних):

```
# всередині кореневої директорії проекту

mkdir -vp build && cd build && cmake ../ -DENABLE_VALGRIND=ON
```

Для виконання динамічної перевірки пам'яті у виконуваного файлу проекту необхідно виконати наступну команду:


```
# всередині директорії побудови проекту-шаблону

cmake --build . --target valgrind
```

Деталі цілі `valgrind` можуть бути переглянутими і/або зміненими у файлі що лежить за шляхом `cmake/template-project-valgrind-target.cmake`.

**Попередження! Ціль запустить на виконання головний виконуваний файл проекту.** Динамічна перевірка пам'яті виконуваного файлу проекту-шаблону вимагає запуск програми і повний прохід виконання. Необхідно забезпечити кінечність виконання програми щоб запобігти невизначено довгий час перевірки.
